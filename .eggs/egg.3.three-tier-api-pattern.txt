ü•ö CHINA'S EGG #3: The Three-Tier API Pattern - Layered Elegance
Created: 2025-09-07 by China the Summary Chicken üêî  
Target: XStream's layered architecture and API design patterns

== THE THREE-TIER ARCHITECTURE ==

XStream implements a sophisticated three-layer approach that separates concerns while maintaining fluent usability. Each tier serves different use cases and complexity levels.

== TIER 1: RAW STREAM LAYER (RSB Foundation) ==

**What It Does:** Pure text manipulation without semantic understanding
**Built On:** RSB/REBEL stream processing framework
**Best For:** Simple find/replace, basic text transforms

**API Pattern:**
```rust
use rsb::prelude::*;

// Direct RSB usage  
stream!(string: &content)
    .sed("old", "new")
    .sed("=\"", "='")
    .to_string()
```

**Characteristics:**
- No knowledge of token structure
- Raw string-to-string transformations
- Powerful regex support via sed
- Foundation for higher tiers

== TIER 2: TOKEN STREAM LAYER (XStream Core) ==

**What It Does:** Token-aware transformations with fluent chaining
**Built On:** RSB streams + token format understanding  
**Best For:** Most text processing tasks involving structured data

**API Pattern:**
```rust
use xstream::transform;

// XStream fluent API
transform(content)
    .translate("localhost", "production")
    .upper()                    // Smart value transformation
    .esc(tx::QUOTES)           // Context-aware escaping  
    .base64(tx::ENCODE)        // Encoding with flags
    .expand()                  // Format adjustment
    .to_string()
```

**Key Features:**
- **Smart Methods**: `.upper()` transforms only values, not keys
- **Context Flags**: `tx::QUOTES`, `tx::HTML`, `tx::BASE64` provide operation context
- **Format Preservation**: Maintains token structure throughout transforms
- **Validation**: Continuous validation ensures output remains parseable
- **Namespace Awareness**: Handles `ns:key=value` patterns correctly

**Transform Categories:**
1. **Case Transforms**: `.upper()`, `.lower()`
2. **Escape/Unescape**: `.esc(tx::QUOTES)`, `.unesc(tx::HTML)`
3. **Encoding**: `.base64(tx::ENCODE)`, `.url(tx::DECODE)`
4. **Quote Management**: `.swap_quotes()`, `.double_quotes()`, `.strip_quotes()`
5. **Namespace Ops**: `.rename_namespace()`, `.rename_key()`
6. **Security**: `.mask_sensitive()` - hides passwords/secrets
7. **Formatting**: `.compact()`, `.expand()`, `.multiline()`
8. **Advanced**: `.custom()`, `.regex()`, `.sort()`

== TIER 3: STRUCTURED DATA LAYER (TokenBucket) ==

**What It Does:** Full structured data operations with collections and validation
**Built On:** Parsed token collections with rich operations
**Best For:** Complex data manipulation, analysis, validation

**API Pattern:**
```rust
use xstream::{TokenBucket, BucketMode};

// Parse into structured format
let bucket = TokenBucket::from_str(&tokens, BucketMode::Strict)?;

// Rich data operations
bucket.extract_keys()
      .filter_by_namespace("config")
      .validate_format()
      .to_flat_format()
```

**Structured Operations:**
- **Analysis**: Count tokens, extract keys/values, find patterns
- **Filtering**: By namespace, key patterns, value types
- **Validation**: Format checking, completeness validation  
- **Export**: Multiple output formats (flat, hierarchical, JSON-like)

== THE TIER INTERACTION PATTERN ==

**Upward Flow (Parse):**
```
Raw Text ‚Üí TokenStream ‚Üí TokenBucket
  ‚Üì           ‚Üì            ‚Üì
"key=val"  .validate()   .extract_keys()
```

**Downward Flow (Generate):**
```
TokenBucket ‚Üí TokenStream ‚Üí Raw Text
     ‚Üì            ‚Üì           ‚Üì
  .to_stream() ‚Üí .compact() ‚Üí String
```

**Cross-Tier Usage:**
```rust
// Start at Tier 3, drop to Tier 2, back to Tier 3
let result = bucket.to_stream()              // Tier 3 ‚Üí 2
    .translate("dev", "prod")                // Tier 2 operations
    .mask_sensitive()                        // Tier 2 operations  
    .parse(BucketMode::Permissive)?;        // Tier 2 ‚Üí 3
```

== API DESIGN PHILOSOPHY ==

**1. Progressive Disclosure:**
- Simple tasks use simple APIs (Tier 2 fluent methods)
- Complex tasks have access to full power (Tier 3 structured ops)
- Raw control always available (Tier 1 RSB streams)

**2. Natural Defaults:**
- Most common operations have shortest syntax
- Context-sensitive behavior (e.g., `.upper()` knows about values)
- Intelligent error messages guide users to correct usage

**3. Composability:**
- Each tier can invoke lower tiers
- Higher tiers can be created from lower tier outputs
- Clean boundaries between concerns

== THE TX ENUM PATTERN ==

**Brilliant Design Choice:** Instead of many method variants, XStream uses contextual flags:

```rust  
pub enum tx {
    ENCODE, DECODE,        // Operations
    QUOTES, HTML, BASE64,  // Contexts
    UPPER, LOWER,          // Targets  
    ALL                    // Catch-all
}

// Usage flexibility
.esc(tx::QUOTES)     // Escape quotes only
.esc(tx::HTML)       // HTML entity escaping
.esc(tx::ALL)        // Everything
.base64(tx::ENCODE)  // Base64 encoding
.base64(tx::DECODE)  // Base64 decoding
```

**Why This Works:**
- Single method handles multiple contexts
- Each transformer interprets flags independently
- Easy to extend without API explosion
- Self-documenting at call sites

== TIER SELECTION GUIDE ==

**Use Tier 1 (RSB Direct) When:**
- Simple find/replace operations
- No token structure awareness needed
- Maximum performance for basic transforms
- Integration with existing RSB code

**Use Tier 2 (TokenStream) When:**
- Working with key=value structured data
- Need format-aware transformations
- Want fluent chaining API
- Most common use case (80% of scenarios)

**Use Tier 3 (TokenBucket) When:**
- Need to analyze token collections
- Complex filtering and validation required
- Working with multiple namespaces
- Exporting to different formats

== ERROR HANDLING ACROSS TIERS ==

**Tier 1**: Basic string errors from RSB
**Tier 2**: Validation errors with helpful context about token format
**Tier 3**: Rich error details with position information and suggestions

**Example Error Progression:**
```
Tier 1: "sed pattern failed"
Tier 2: "Malformed token 'key=value with space': space before '=' not allowed"  
Tier 3: "Token at position 2 in namespace 'config': Invalid key format 'bad key'"
```

== REVOLUTIONARY ASPECTS ==

**vs Traditional Rust:**
- Most Rust APIs force you to pick an abstraction level upfront
- XStream lets you move between levels fluidly
- No "parse once, work with objects" limitation

**vs Other Text Libraries:**
- Most libraries are either low-level (regex) or high-level (parsers)
- XStream provides productive middle ground with escape hatches
- Maintains Unix pipeline aesthetics throughout

This three-tier approach enables both simple scripts and complex data processing while maintaining the intuitive feel of bash text processing!

== DISCLAIMER ==
This summary is based on source code analysis and architecture patterns observed. Actual API capabilities should be verified through testing and documentation review.